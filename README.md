![](./media/image1.jpeg){width="6.5in" height="4.878472222222222in"}

# **[תוכן עניינים]{.underline}** {#תוכן-עניינים .TOC-Heading}

**מבוא3**

**תיאור הבעיה3**

**תיאור הפתרון4**

**מבט על של התוכנה7**

**הדגמת ריצה8**

**גרפים ונתונים עבור ריצות שונות10**

**מסקנות וסיכום14**

**[[מבוא:]{.underline}]{dir="rtl"}**

Movie recommender systems [הינה מערכת שממליצה למשתמש על סרטים על פי
העדפה אישית.]{dir="rtl"} [\
]{dir="rtl"}

[\
**[תיאור הבעיה:]{.underline}**]{dir="rtl"}

[בעידן של היום, בו קיימים שירותי סטרימינג וספריות וידאו דיגיטליות עם
כמויות אדירות של סרטים, נוצר צורך לבצע סינון כלשהו עבור הצופה על מנת
לספק לו את התכנים המתאימים ביותר.\
[\
**חלוקת הבעיה:**]{.underline}]{dir="rtl"}

1.  [[**יצירת רשימת סרטים:**\
    ]{.underline}האפליקציה צריכה לספק סרטים עליהם נוכל לבצע את הבדיקה
    ובסוף להציע למשתמש את הסרטים המתאימים לו מרשימה זו.]{dir="rtl"}

2.  **[[קריטריונים:]{.underline}]{dir="rtl"}**

[על מנת לספק סרטים המתאימים להעדפה של המשתמש עלינו ליצור רשימת
קריטריונים אותם נוכל לדרוש לפיהם האפליקציה תקבל מידע לגבי העדפות
המשתמש.]{dir="rtl"}

3.  **[[חישוב התאמה לכל סרט:]{.underline}]{dir="rtl"}**

[לאחר שיצרנו רשימת סרטים עלינו לחשב התאמה של כל סרט ברשימה זו
לקריטריונים שהמשתמש סיפק.]{dir="rtl"}

4.  **[[חיפוש הסרטים המתאימים]{dir="rtl"}:]{.underline}**

[לאחר שנחשב לכל סרט את מידת ההתאמה שלו בהתאם לקריטריונים של המשתמש נרצה
להחזיר רשימה של הסרטים המתאימים ביותר.]{dir="rtl"}

**[[תיאור הפתרון:]{.underline}]{dir="rtl"}**

[על מנת להתמודד עם הבעיה יצרנו אפליקציה שמבקשת מהמשתמש העדפה עבור מספר
קריטריונים ומחזירה לו פלט של הסרטים המתאימים ביותר. מימוש הפתרון נעשה
באמצעות ספריית]{dir="rtl"} Ec-Kity [שמספקת לנו גישה נוחה לעבודה עם
אלגוריתמים אבולוציוניים. התוכנית תקבל רשימת סרטים קיימים והעדפות משתמש
ולאחר ביצוע אלגוריתם אבולציוני מחזירה את הסרטים המתאימים ביותר. במימוש
שלנו החלטנו לבצע אלגוריתם אבולוציוני באמצעות וקטורים עליו נפרט
בהמשך.]{dir="rtl"}

**[[חלוקת שלבי הפתרון:]{.underline}]{dir="rtl"}**

1.  [[**יצירת רשימת סרטים:**\
    ]{.underline}התוכנית שולחת בקשות ל-]{dir="rtl"}API [קיים שמבוסס על
    התוכן ב-]{dir="rtl"}Netflix [ישראל שמתוכו אנו בונים]{dir="rtl"}
    database [לוקאלי עדכני של סרטים.]{dir="rtl"}

**[מגבלות:]{dir="rtl"}**

[לא מצאנו]{dir="rtl"} API [חינמי של סרטים, ה-]{dir="rtl"}API [איתו אנו
עובדים מוגבל בכמות בקשות.]{dir="rtl"}

[\
**פתרון למגבלות:**]{dir="rtl"}

[בקשה חד פעמית של כמות מידע אפשרית מה-]{dir="rtl"}API
[ויצירת]{dir="rtl"} database [לוקאלי.]{dir="rtl"}

2.  **[[קריטריונים:]{.underline}]{dir="rtl"}**

[לאחר התבוננות בשדות החוזרים עבור כל סרט ב-]{dir="rtl"}API [איתו אנו
עובדים בחרנו את השדות המתאימים ביותר לדירוג סרט על ידי הצופה. השדות
שנבחרו הינם: ז\'אנר, שפת מקור, שנת יציאה מינמלית ואורך סרט מקסימלי.\
נוסף על כך ישנה התחשבות בקריטיריון נוסף שאינו תלוי במשתמש וזהו קריטריון
דירוג הסרט ב-]{dir="rtl"}IMDB[.]{dir="rtl"}

[**חישוב ציון לכל סרט:**[\
]{.underline}לאחר שהמשתמש סיפק את המידע הדרוש בהתאם לשדות המתאימים מתבצע
חישוב ציון ההתאמה עבור כל הסרטים, חישוב זה מבוצע פעם אחת שבסופו נקבל
בחזרה]{dir="rtl"}

[וקטור -]{dir="rtl"} movieScores[, בו כל אינדקס מייצג את ציון הסרט
המתאים לו ברשימת הסרטים.]{dir="rtl"}

[**פירוט חישוב הציון לכל סרט:\
**בתחילת העבודה על הפרוייקט קבענו חלוקה שווה לכל אחד מהפרמטרים אך לאחר
קבלת תוצאות רבות שאינן רלוונטיות נתנו למשתמש שתי אפשרויות חדשות:\
1. לבצע את­­ התיעדוף לכל קריטריון בעצמו.]{dir="rtl"}

[2. לעבוד עם חלוקה דיפולטיבית (עליה אנו ממליצים).]{dir="rtl"}

[\
החישוב מתבצע באמצעות הפונקציה]{dir="rtl"} grading_movies[, שמקבלת
כארגומנטים את תיעדוף הקריטריונים של המשתמש ,רשימת הסרטים ומספר הז\'אנרים
שנבחרו על ידי המשתמש.\
הפונקציה מבצעת חישוב קבוע מראש על פי החלוקה לאחוזים שנקבעה על ידי המשתמש
תוך כדי התייחסות גם לדירוג הסרט ב-]{dir="rtl"}IMDB[.\
סך כל העדפות המשתמש מקבל נקודה 1 ודירוג הסרט]{dir="rtl"} IMDB [מקבל
נקודה 1, סה\"כ הציון הגבוה ביותר שסרט יכול לקבל הוא 2
נקודות.]{dir="rtl"}

3.  **[[חיפוש הסרטים המתאימים]{dir="rtl"}:]{.underline}**

[לאחר שיצרנו את הווקטור]{dir="rtl"} movieScores [אנו מתחילים בשלב
האלגוריתם האבולוציוני.\
האלגוריתם מייצר]{dir="rtl"} initial-population [שמורכבת
מ-]{dir="rtl"}individuals[, כאשר כל]{dir="rtl"} individual [מאותחל באופן
אקראי.]{dir="rtl"} Individual [הוא וקטור של ביטים (]{dir="rtl"}0 [עבור
אי-המלצה ו-1 עבור המלצה) שאורכו כמספר הסרטים הכולל וכל אינדקס בו מתאים
לאינדקס של סרט ב-]{dir="rtl"}movieScore[.]{dir="rtl"}

[לכל]{dir="rtl"} individual [נרצה לבצע חישוב של]{dir="rtl"} fitness
[שזהו למעשה חישוב התאמה מיטבית למערך אשר מתבסס על ציוני ההתאמה
ב-]{dir="rtl"}movieScores[.]{dir="rtl"}

[נשים לב כי מדובר בבעיית מקסימום עליה נפרט בהמשך.]{dir="rtl"}

**[חישוב]{dir="rtl"} fitness[:]{dir="rtl"}**

[\
נשתמש במחלקה]{dir="rtl"} movieEvaluator [הממששת את הפונקציה]{dir="rtl"}
evaluate_individual()[.\
המחלקה מקבלת כארגומנטים את הווקטור]{dir="rtl"} movieScores [ואת
השדה]{dir="rtl"} lowerBoundGrade [המייצג את ציון ההתאמה הנמוך ביותר שאנו
מגדירים כמספק. בקוד שלנו בחרנו]{dir="rtl"} lowerBoundGrade = 1.5[, הסיבה
לכך היא על מנת להבטיח כי גם סרט שמדורג עם הציון הכי גבוה שניתן לבחור
(100), יקבל תוצאה טובה שתאפשר לו להכנס לרשימה אך ורק אם אחוז ההתאמה שלו
לקריטריונים של המשתמש הוא לפחות 50 אחוז.]{dir="rtl"}

[הפונקציה]{dir="rtl"} evaluate_individual() [רצה באופן הבא:]{dir="rtl"}

[\
לכל אינדקס]{dir="rtl"} i [בווקטור]{dir="rtl"} individual [המייצג
סרט:]{dir="rtl"}

[אם הסרט ב-]{dir="rtl"}movieScores\[i\] [גדול שווה
ל-]{dir="rtl"}lowerBoundGrade [אז נכפול את הציון]{dir="rtl"}

> [ב-]{dir="rtl"}individual\[i\][.\
> אחרת, נכפול את]{dir="rtl"} individual\[i\] [בערך שלילי של תוצאת חיסור
> הציון מפרמטר הניקוד (נקודה אחת עבור דירוג הסרט ונקודה נוספת עבור
> הקריטריונים של המשתמש).\
> באופן זה כל הסרטים שלא עברו את סף ה-]{dir="rtl"} lowerBoundGrade[יקבלו
> ציון שלילי אך סרטים שקרובים יותר לסף יקבלו ציון גבוה יותר (קרוב יותר
> ל-0) מאשר סרטים שרחוקים מהסף.]{dir="rtl"}
>
> [נחבר את הערכים שהתקבלו מכל איטרציה והערך הסופי מייצג את
> ה-]{dir="rtl"}fitness[. נרצה לקבל ציון הכי גבוה עבור
> ה-]{dir="rtl"}fitness [לכן הגדרנו]{dir="rtl"} higher is better =
> true[.]{dir="rtl"}
>
> **genetic operators[:]{dir="rtl"}**
>
> [\
> השתמשנו בשני סוגי ה-]{dir="rtl"}genetic operators
> [הבסיסיים]{dir="rtl"} CrossOver [ו-]{dir="rtl"}Mutation[.בהרצות
> הראשונות עבדנו עם]{dir="rtl"} data base [קטן יחסית (כ-30 סרטים) ועבור
> הכמות הזו השתמשנו ב:\
> ]{dir="rtl"}VectorKPointsCrossover
> [ו-]{dir="rtl"}BitStringVectorNFlipMutation [הנתונים
> בחבילה]{dir="rtl"} Ec-Kity[.\
> ]{dir="rtl"}
>
> [עבור מספר סרטים קטן קיבלנו תוצאות טובות בשימוש עם ה-]{dir="rtl"}
> genetic operators[הללו.]{dir="rtl"}
>
> [לאחר הגדלת ה-]{dir="rtl"}data base [הגענו למספר של כ-560 סרטים
> ונתקלנו בבעיה להגיע לתוצאה מיטבית.]{dir="rtl"}
>
> [לאחר מספר ניסויים שמנו לב כי הגדלת האוכלוסייה מסייעת להגיע לתוצאה
> טובה יותר, אך ככל שהגדלנו את האוכלוסייה נתקלנו בחישובים כבדים יותר
> שלקחו המון זמן.\
> על מנת להימנע מחישובים כבדים עקב גישת הגדלת האוכלוסייה החלטנו לנסות
> לבצע שינוי באופן הפעולה של ה-]{dir="rtl"} genetic operators[בהם אנו
> משתמשים. תחילה ניסינו ליצור]{dir="rtl"} Crossover [חדש:]{dir="rtl"}

-   [VectorKPointsCrossoverStrongestCross]{.underline}[:]{dir="rtl"}

> [\
> ניסיון ראשון:]{dir="rtl"}
>
> [בתהליך הזה אנו בוחרים נקודה רנדומלית בה נחלק כל אחד מההורים באופן
> דומה לחלוקה ב-]{dir="rtl"} VectorKPointsCrossover [ונבדוק מיהו הווקטור
> הטוב ביותר הנוצר מבין השניים הבאים:\
> ילד שנוצר מהחלק הימני של הורה 1 והחלק השמאלי של הורה 2,]{dir="rtl"}

[ילד שנוצר מהחלק הימני של הורה 2 והחלק השמאלי של הורה 1.]{dir="rtl"}

[התהליך שיפר במקצת את התוצאות אך עדיין לא הגיע לתוצאה מספקת.]{dir="rtl"}

> [ניסיון שני:]{dir="rtl"}
>
> [בתהליך הזה אנו בוחרים נקודה רנדומלית בה נחלק כל אחד מההורים בצורה
> דומה לחלוקה ב-]{dir="rtl"} VectorKPointsCrossover[, בשונה מהניסיון
> הראשון הפעם נתבונן גם בהורים ונבדוק מיהו הוקטור הטוב ביותר הנוצר מבין
> הארבעה הבאים:\
> הורה 1,\
> הורה 2,\
> ילד שנוצר מהחלק הימני של הורה 1 והחלק השמאלי של הורה 2,]{dir="rtl"}
>
> [ילד שנוצר מהחלק הימני של הורה 2 והחלק השמאלי של הורה 1.\
> \
> התהליך גם שיפר את התוצאות אך עדיין לא בצורה מספקת.]{dir="rtl"}

[לאחר שיצירת]{dir="rtl"} VectorKPointsCrossoverStrongestCross [לא סיפק
פתרון מיטבי לבעיה החלטנו לייצר גם]{dir="rtl"} Mutation operator [חדש
--]{dir="rtl"} PrioritizedBitStringVectorNFlipMutation[.]{dir="rtl"}

-   [PrioritizedBitStringVectorNFlipMutation[:]{dir="rtl"}]{.underline}

> [בתהליך זה נבצע]{dir="rtl"} bit-mutation [בצורה הסתברותית בדומה לדרך
> בה פועל]{dir="rtl"} BitStringVectorNFlipMutation [אך בשונה ממנו, לאחר
> הבחירה ההסתברותית אם נבחר לבצע]{dir="rtl"} bit-flip [נפעיל שני אילוצים
> נוספים]{dir="rtl"}:

1.  [אם]{dir="rtl"} individual\[i\]=1 [וגם קיבלנו תוצאה שווה גדולה
    ל-]{dir="rtl"} lowerBoundGrade [לא נבצע]{dir="rtl"}
    bit-flip[.]{dir="rtl"}

2.  [אם]{dir="rtl"} individual\[i\]=0 [וגם קיבלנו תוצאה מתחת
    ל-]{dir="rtl"}lowerBoundGrade [לא נבצע]{dir="rtl"}
    bit-flip[.]{dir="rtl"}

> [לאחר הוספת]{dir="rtl"} PrioritizedBitStringVectorNFlipMutation
> [התוצאות שקיבלנו השתפרו לרמת פלט מספקת גם במימוש עם]{dir="rtl"}
> VectorKPointsCrossoverStrongestCross [אותו יצרנו וגם
> במימוש]{dir="rtl"} VectorKPointsCrossover [שהיה קיים
> בחבילת]{dir="rtl"} Ec-Kity[.]{dir="rtl"}
>
> **Selection[:]{dir="rtl"}**

[בחרנו להשתמש ב-]{dir="rtl"}tournament selection [בגודל 2
ו-]{dir="rtl"}higher is better = true[.\
]{dir="rtl"}

**[[מבט על של התוכנה:]{.underline}]{dir="rtl"}**

[התוכנה מבצעת אתחול של ה-]{dir="rtl"}data base [(במידה ולא קיים) באמצעות
הפונקציה]{dir="rtl"} load_movies[.]{dir="rtl"}

[התוכנה מקבלת מהמשתמש מידע לגבי דירוג הקריטריונים.]{dir="rtl"}

[התוכנה מבצעת חישוב של דירוג הסרטים על סמך דירוג המשתמש באמצעות
הפונקציה]{dir="rtl"} grading_movies[.]{dir="rtl"}

[התוכנה מבצעת אתחול של האלגוריתם.]{dir="rtl"}

[התוכנה מבצעת]{dir="rtl"} algo.evolve() [ותתחיל את ריצת האלגוריתם
האבולוציוני.]{dir="rtl"}

[התוכנה תריץ את]{dir="rtl"} algo.execute() [ותשמור את וקטור הפלט הטוב
ביותר ב-]{dir="rtl"}result[.]{dir="rtl"}

[במידה והאלגוריתם לא מצא סרטים מתאימים נאפשר למשתמש להכניס קריטריונים
חדשים.]{dir="rtl"}

[במידה והאלגוריתם מצא לפחות סרט אחד נחזיר למשתמש רשימת סרטים
אפשריים]{dir="rtl"} [אחרת נאפשר למתשמש להזין נתונים חדשים.]{dir="rtl"}

**[[הדגמת ריצה:]{.underline}]{dir="rtl"}**

[המשתמש מקבל אפשרות לבחור האם להזין בעצמו את המשקל לכל קריטריון או
להחליט על המשקל בעצמו.]{dir="rtl"}

![](./media/image2.png){width="6.5in" height="0.4048611111111111in"}

[נבצע ריצה עם ההמלצה שלנו:]{dir="rtl"}

![](./media/image3.png){width="5.224636920384952in"
height="2.3018963254593174in"}

[המשתמש יבחר ז\'אנר רצוי (אחד או יותר) ולאחר כל בחירה של ז\'אנר ילחץ
על]{dir="rtl"} enter[. לאחר שסיים לבחור את כל הז\'אנרים המשתמש יזין למסך
את המילה]{dir="rtl"} 'finish' [ולאחר מכן ילחץ על]{dir="rtl"}
enter[.]{dir="rtl"}

![](./media/image4.png){width="5.021534339457568in"
height="0.4375612423447069in"}

[המתמש יבחר שפת מקור רצויה (אחת או יותר) באופן זהה לבחירת
הז\'אנר.]{dir="rtl"}

![](./media/image5.png){width="6.5in" height="0.8020833333333334in"}

[כעת המשתמש יבחר שנת יציאה מינימלית ואורך סרט מקסימלי.]{dir="rtl"}

![](./media/image6.png){width="6.1258552055993in"
height="0.40630686789151355in"}

[האלגוריתם יעצור במידה והגיע להתאמה לפי ה-]{dir="rtl"}threshold [ (בקוד
שלנו בחרנו 80 אחוז התאמה, כלומר]{dir="rtl"} threshold = 0.2 \*
max_fitness[).]{dir="rtl"}

![](./media/image7.png){width="2.0106977252843397in"
height="1.2605927384076991in"}

[בסיום ריצת האלגוריתם האבולוציוני התוכנית תדפיס רשימה של כל הסרטים
המומלצים בהתאם לקריטריונים ודרישת המשתמש (במידה ולא נמצאו כאלה התוכנית
תציע למשתמש להתחיל את התהליך מחדש).]{dir="rtl"}

![](./media/image8.png){width="2.5836942257217848in"
height="2.5524398512685913in"}

**[[גרפים ונתונים עבור ריצות שונות:]{.underline}]{dir="rtl"}**

[**בכל דוגמאות ההרצה השתמשנו בנתונים זהים:**\
]{dir="rtl"}population_size=300 [(שונה רק בריצה מספר 3)\
]{dir="rtl"}MAX_GENERATION = 300

Genres: 10749, 35\
Original language = en\
Min year = 2000\
Max length = 130

[\*תזכורת -- האלגוריתם יעצור לפני הגעה ל-]{dir="rtl"}MAX_GENERATION [אם
מדד ה-]{dir="rtl"}fitness [גדול או שווה ל-80% מ-]{dir="rtl"}max
fitness[.]{dir="rtl"}

[**ריצה 1** --]{dir="rtl"} data base [קטן של סרטים עם]{dir="rtl"}
VectorKPointsCrossover
[ו-]{dir="rtl"}BitStringVectorNFlipMutation[:]{dir="rtl"}

Max fitness = 4.54\
matched movies = 3\
Best fitness = 3.72\
total movies in DB: 88\
recommended movies in DB: 4

![](./media/image9.png){width="4.73393372703412in"
height="3.5504483814523184in"}

[**ריצה 2** --]{dir="rtl"} data base [גדול של סרטים עם]{dir="rtl"}
VectorKPointsCrossover
[ו-]{dir="rtl"}BitStringVectorNFlipMutation[:]{dir="rtl"}

Max Fitness = 31.11\
matched movies = 20\
Best Fitness = -27.540000000000003\
total movies in DB: 568\
recommended movies in DB: 86

![](./media/image10.png){width="4.263868110236221in"
height="3.1979024496937885in"}

![](./media/image11.png){width="4.43125in"
height="3.323611111111111in"}[**ריצה 3** --]{dir="rtl"} data base [גדול
של סרטים עם]{dir="rtl"} VectorKPointsCrossover
[ו-]{dir="rtl"}BitStringVectorNFlipMutation [עם הגדלה של
ה-]{dir="rtl"}initial population[:]{dir="rtl"}

[[שינוי אוכלוסייה מ-300 ל-5,000:]{.underline}]{dir="rtl"}

Max fitness = 31.11\
matched movies = 20\
Best fitness = 19.28\
total movies in DB: 568\
recommended movies in DB: 33

![](./media/image12.png){width="4.143939195100613in"
height="3.1079549431321083in"}[[שינוי אוכלוסייה
ל-10,000:]{.underline}]{dir="rtl"}

Max fitness = 31.11\
matched movies = 20\
Best fitness = 25.28\
total movies in DB: 568\
recommended movies in DB: 27

**[ריצה]{dir="rtl"} 4** [--]{dir="rtl"} data base [גדול של סרטים
עם]{dir="rtl"} VectorKPointsCrossoverStrongestCross [
ו-]{dir="rtl"}BitStringVectorNFlipMutation[:]{dir="rtl"}

Max fitness = 31.11\
matched movies = 20\
Best fitness = -30.239999999999995\
total movies in DB: 568\
recommended movies in DB: 90

![](./media/image13.png){width="4.226010498687664in"
height="3.169508967629046in"}

**[ריצה]{dir="rtl"} 5** [--]{dir="rtl"} data base [גדול של סרטים
עם]{dir="rtl"} VectorKPointsCrossover [ ו-]{dir="rtl"}
PrioritizedBitStringVectorNFlipMutation[:]{dir="rtl"}

![](./media/image14.png){width="4.1in" height="3.075in"}Max fitness =
31.11\
matched movies = 20\
Best fitness = 25.439999999999998\
total movies in DB: 568\
recommended movies in DB: 21

**[ריצה]{dir="rtl"} 6** [--]{dir="rtl"} data base [גדול של סרטים
עם]{dir="rtl"} VectorKPointsCrossoverStrongestCross [ ו-]{dir="rtl"}
PrioritizedBitStringVectorNFlipMutation[:]{dir="rtl"}

![](./media/image15.png){width="3.9327734033245845in"
height="2.949580052493438in"}Max fitness = 31.11\
matched movies = 20\
Best fitness = 24.830000000000002\
total movies in DB: 568\
recommended movies in DB: 16

**[[מסקנות וסיכום:]{.underline}]{dir="rtl"}**

[**נסכם את השינויים מריצה לריצה:**\
ריצה 1: קיבלנו תוצאה רצויה (מעל 80% אחוז התאמה) לאחר 40 דורות.\
ריצה 2: קיבלנו תוצאה לא רצויה, וכפי שניתן לראות קצב העלייה הופך לאיטי
יותר לאחר מספר דורות.\
ריצה 3: גם לאחר העלת האוכלוסייה לגודל של 5,000 עדיין לא הגענו לתוצאה
רצויה לאחר 300 דורות, עם זאת בריצה של אוכלוסייה בגודל של 10,000 הצלחנו
להגיע לתוצאה רצויה לאחר כ-200 דורות. ניתן לראות כי הגדלת האוכלוסייה
משפרת את התוצאה ואף עבור אוכלוסייה גדולה מספיק התוצאה הרצויה מתקבלת גם
לאחר פחות מ-300 דורות.\
ריצה 4: קיבלנו תוצאה לא רצויה, בדומה לריצה מספר 2, קצב העלייה הופך איטי
יותר לאחר מספר דורות.\
ריצות 5 ו-6: בשתי הריצות הללו קיבלנו תוצאה רצויה, ריצה 5 הצליחה לעצור
לאחר 100 דורות וריצה 6 לא עצרה לאחר 100 דורות אך ניתן להבחין לפי הגרף כי
החל מדור 150 לא היה שינוי בערך ה-]{dir="rtl"}fitness [והתוצאה מאוד קרובה
ל-80% התאמה.\
כמו כן ניתן להבחין כי בריצה 6 קצב העלייה בין הדורות 0 ל-100 מהיר יותר
מקצב העלייה בריצה 5, כלומר שתי הריצות מגיעות לתוצאה הרצויה, אך ריצה 6
מגיעה לתוצאה זו בקצב מהיר יותר בעקבות השימוש ב-]{dir="rtl"}
VectorKPointsCrossoverStrongestCross [שמתעדף את וקטור הקרוס-אובר הטוב
ביותר.]{dir="rtl"}

[כפי שניתן לראות מהריצות השונות, עבור קלט קטן התוכנית מצליחה להגיע
לתוצאות טובות בשימוש עם]{dir="rtl"} VectorKPointsCrossover
[ו-]{dir="rtl"}BitStringVectorNFlipMutation[. אך כאשר גודל הקלט עולה יש
צורך להגדיל את גודל האוכלוסייה על מנת לשפר את התוצאות של התהליך
האבולוציוני. (ניתן גם לבצע שינוי בכמות הדורות על מנת לאפשר איטרציות
נוספות בניסיון לשפר את איכות הפלט)]{dir="rtl"}

[עם זאת הגדלת אוכלוסייה היא פתרון בעייתי, שכן ככל שכמות הסרטים תגדל כך
נצטרך גם להגדיל את כמות האוכלוסייה בהתאם. פתרון זה אינו יעיל ודורש
חישובים כבדים ומחשבים חזקים יותר.]{dir="rtl"}

[לסיכום לאחר הרצת כל ששת סוגי הריצה השונים מספר רב של פעמים, ניתן להסיק
כי הפתרון היעיל ביותר הוא שימוש ב-]{dir="rtl"}
PrioritizedBitStringVectorNFlipMutation [שמבצע מוטציות רק כאשר המוטציה
משפרת את ה-]{dir="rtl"}fitness [של הווקטור. גישה זו נותנת תוצאות זהות גם
עבור]{dir="rtl"} VectorKPointsCrossover [וגם עבור]{dir="rtl"}
VectorKPointsCrossoverStrongestCross [גם כאשר גודל האוכלוסייה נשאר נמוך
(300).]{dir="rtl"}
